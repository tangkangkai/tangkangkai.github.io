
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>KK's Coding Blog</title>
  <meta name="author" content="Kangkai Tang">

  
  <meta name="description" content="Q1: Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://tangkangkai.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="KK's Coding Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='//fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='//fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">KK's Coding Blog</a></h1>
  
    <h2>keep coding keep pushing keep believing</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:tangkangkai.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/25/remove-duplicates-in-array/">Remove Duplicates in Array</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-25T22:37:26-07:00" pubdate data-updated="true">Jun 25<sup>th</sup>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Q1: Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory.</p>

<p>Q2:Follow up for &ldquo;Remove Duplicates&rdquo;: What if duplicates are allowed at most twice?</p>

<hr />

<p>If we adjust the position of every element whenever there happens a duplicate, the running time would be large. In order to be more efficient, we can do in this way: if the element is the same with the previous one, we increase a &ldquo;count&rdquo;(recording the offset) variable by one. When traversing through every element, say index of i, we adjust the position from i to i &ndash; count.</p>

<p>&lsquo;&rsquo;&lsquo;java Remove duplicate start:16 mark:28</p>

<pre><code>    public int removeDuplicates1(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }

    // we use count to show the offset
    int count = 0;

    for (int i = 1; i &lt; A.length; i++) {
        if (A[i - 1] == A[i]) {
            count++;
        } else {
            A[i - count] = A[i];
        }
    }

    return A.length - count;
}
</code></pre>

<p>&lsquo;&rsquo;&#8217;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/25/bfs-and-dfs/">BFS and DFS</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-25T07:33:17-07:00" pubdate data-updated="true">Jun 25<sup>th</sup>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Recently I&rsquo;ve been doing <a href="https://oj.leetcode.com/problems">LeetCode Problems</a> and found it&rsquo;s tons of fun. Meanwhile I felt my lacking of solid way solving basic questions, e.g. the topic of the post today : BFS and DFS.I searched through the Internet and found <a href="http://www.codeproject.com/Articles/32212/Introduction-to-Graph-with-Breadth-First-Search-BF">this post</a> really helps me a lot.</p>

<p>Basically it&rsquo;s important to know which data structure we use to implement the algorithm, for DFS we use Stack and for BFS we use Queue.</p>

<p><strong>The steps for DFS:</strong></p>

<blockquote><p>Step 1: Push the root node in the Stack.<br/>
Step 2: Loop until stack is empty. <br/>
Step 3: Peek the node of the stack.<br/>
Step 4: If the node has unvisited child nodes, get the unvisited child node, mark it as traversed and push it on stack. <br/>
Step 5: If the node does not have any unvisited child nodes, pop the node from the stack.</p></blockquote>

<p><strong>The steps for DFS:</strong></p>

<blockquote><p>Step 1: Push the root node in the Queue.<br/>
Step 2: Loop until the queue is empty.<br/>
Step 3: Remove the node from the Queue. <br/>
Step 4: If the removed node has unvisited child nodes, mark them as visited and insert the unvisited children in the queue.</p></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/23/my-first-post/">My First Post</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-23T16:59:37-07:00" pubdate data-updated="true">Jun 23<sup>rd</sup>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Hello every one. This will be my new home for my coding journey.<br/>
Here is my code snippet (also used for testing the blog :P)</p>

<div><script src='https://gist.github.com/9968025.js'></script>
<noscript><pre><code>import java.util.Stack;

import org.junit.Test;

public class TreeTraversal {

    Stack&lt;BinaryTreeNode&gt; btStack = new Stack&lt;&gt;();
    BinaryTreeNode current = null;

    // Pre-Order recursion
    public void preOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            System.out.print(bt.data + &quot;  &quot;);
            preOrderRecursion(bt.left);
            preOrderRecursion(bt.right);
        }
    }

    // Pre-Order interation
    public void preOrderIteration(BinaryTreeNode bt) {
        BinaryTreeNode current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                System.out.print(current.data + &quot;  &quot;);// print the data when
                                                        // pushed into the stack
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                current = current.right;
            }
        }
    }

    // In-Order recursion
    public void inOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            inOrderRecursion(bt.left);
            System.out.print(bt.data + &quot;  &quot;);
            inOrderRecursion(bt.right);
        }
    }

    // In-Order Iteration
    public void inOrderIteration(BinaryTreeNode bt) {
        current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                System.out.print(current.data + &quot;  &quot;);// print the data when
                                                        // popped out of stack
                current = current.right;
            }
        }

    }

    // Post-Order Recursion
    public void postOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            postOrderRecursion(bt.left);
            postOrderRecursion(bt.right);
            System.out.print(bt.data + &quot;  &quot;);
        }

    }

    // Post-Order Iteration
    public void postOrderIteration(BinaryTreeNode bt) {
        current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                if (current.isFinished) { // we use isFinished as a flag to see
                                            // if both of the children have been
                                            // visited.
                    System.out.print(current.data + &quot;  &quot;);
                    current = null;
                } else {
                    current.isFinished = true;
                    btStack.push(current);
                    current = current.right;
                }
            }
        }

    }

    @Test
    public void generalTest() {
        BinaryTreeNode root = new BinaryTreeNode(1);
        BinaryTreeNode left = new BinaryTreeNode(2);
        BinaryTreeNode right = new BinaryTreeNode(3);
        root.left = left;
        root.right = right;

        left.left = new BinaryTreeNode(4);
        left.right = new BinaryTreeNode(5);
        right.left = new BinaryTreeNode(6);
        right.right = new BinaryTreeNode(7);
        System.out.println(&quot;========Pre Order Test=========&quot;);
        preOrderRecursion(root);
        System.out.println();
        preOrderIteration(root);
        System.out.println();

        System.out.println(&quot;========In Order Test=========&quot;);
        inOrderRecursion(root);
        System.out.println();
        inOrderIteration(root);
        System.out.println();

        System.out.println(&quot;========Post Order Test=========&quot;);
        postOrderRecursion(root);
        System.out.println();
        postOrderIteration(root);
    }
}

class BinaryTreeNode {
    int data;
    boolean isFinished;
    BinaryTreeNode left = null;
    BinaryTreeNode right = null;

    public BinaryTreeNode(int data) {
        this.data = data;
    }
}
</code></pre></noscript></div>



</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Kangkai Tang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
