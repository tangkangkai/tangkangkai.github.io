<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | KK's Coding Blog]]></title>
  <link href="http://tangkangkai.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://tangkangkai.github.io/"/>
  <updated>2014-06-26T17:50:40-07:00</updated>
  <id>http://tangkangkai.github.io/</id>
  <author>
    <name><![CDATA[Kangkai Tang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BFS and DFS]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/25/bfs-and-dfs/"/>
    <updated>2014-06-25T07:33:17-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/25/bfs-and-dfs</id>
    <content type="html"><![CDATA[<p>Recently I&rsquo;ve been doing <a href="https://oj.leetcode.com/problems">LeetCode Problems</a> and found it&rsquo;s tons of fun. Meanwhile I felt my lacking of solid way solving basic questions, e.g. the topic of the post today : BFS and DFS.I searched through the Internet and found <a href="http://www.codeproject.com/Articles/32212/Introduction-to-Graph-with-Breadth-First-Search-BF">this post</a> really helps me a lot.</p>

<p>Basically it&rsquo;s important to know which data structure we use to implement the algorithm, for DFS we use Stack and for BFS we use Queue.</p>

<p><strong>The steps for DFS:</strong></p>

<blockquote><p>Step 1: Push the root node in the Stack.<br/>
Step 2: Loop until stack is empty. <br/>
Step 3: Peek the node of the stack.<br/>
Step 4: If the node has unvisited child nodes, get the unvisited child node, mark it as traversed and push it on stack. <br/>
Step 5: If the node does not have any unvisited child nodes, pop the node from the stack.</p></blockquote>

<p><strong>The steps for DFS:</strong></p>

<blockquote><p>Step 1: Push the root node in the Queue.<br/>
Step 2: Loop until the queue is empty.<br/>
Step 3: Remove the node from the Queue. <br/>
Step 4: If the removed node has unvisited child nodes, mark them as visited and insert the unvisited children in the queue.</p></blockquote>
]]></content>
  </entry>
  
</feed>
