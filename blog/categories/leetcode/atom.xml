<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Leetcode | KK's Coding Blog]]></title>
  <link href="http://tangkangkai.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://tangkangkai.github.io/"/>
  <updated>2014-06-30T11:46:47-07:00</updated>
  <id>http://tangkangkai.github.io/</id>
  <author>
    <name><![CDATA[Kangkai Tang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Permutation Sequence]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/30/permutation-sequence/"/>
    <updated>2014-06-30T11:40:31-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/30/permutation-sequence</id>
    <content type="html"><![CDATA[<p><a href="https://oj.leetcode.com/problems/permutation-sequence/">Question</a></p>

<hr />

<p>We have already solved <a href="http://www.codertkk.com/blog/2014/06/29/next-permutation/">Next Permutation</a> question, with the help of this, we just need a loop to find the _k_th string. Here are the code:</p>

<pre><code>public String getPermutation(int n, int k) {
	int[] num = new int[n];
	for (int i = 0; i &lt; n; i++) {
		num[i] = i + 1;
	}
	
	for(int i = 1; i &lt; k; i++ ) {
		nextPermutation(num);
	}
		
	StringBuilder sb = new StringBuilder();
	for(int i : num) {
		sb.append(i);
	}
	return sb.toString();
}
</code></pre>
<p>{.language-java}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next Permutation]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/29/next-permutation/"/>
    <updated>2014-06-29T22:33:09-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/29/next-permutation</id>
    <content type="html"><![CDATA[<p><a href="https://oj.leetcode.com/problems/next-permutation/">Question</a></p>

<hr />

<p>For this question, in order to get the <em>next</em> larger permutation, we need start from the last element, compare it with the previous element to see if it’s larger(if not, swapping them would make the number smaller). We start from index <em>arr.length</em> -2 to 0 to see which element could be swapped, say we are now at index i, then we use j to traverse from index <em>arr.length</em> -1 to i - 1 to see if arr[i] is smaller than arr[j], if so we can safely swap them(As if we come to index i, the elements from index i + 1 to <em>arr.length</em> -1 must be in decreasing order, otherwise, the swap would happen before i). After we swap, there need two things to be done, first we sort the array after index i(here I use <a href="http://www.sorting-algorithms.com/insertion-sort">insertion sort</a>), then we return directly. If the previous requirement not met, we simply sort and return.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span class="directive">public</span> <span class="type">void</span> nextPermutation(<span class="type">int</span><span class="type">[]</span> num) {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    <span class="type">int</span> lastIndex = num.length - <span class="integer">1</span>;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="keyword">for</span> (<span class="type">int</span> i = lastIndex - <span class="integer">1</span>; i &gt;= <span class="integer">0</span>; i--) {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        <span class="keyword">for</span> (<span class="type">int</span> j = lastIndex; j &gt; i; j--) {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>            <span class="keyword">if</span> (num[i] &lt; num[j]) {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>                swap(num, i, j);
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>                <span class="keyword">for</span> (<span class="type">int</span> m = i + <span class="integer">2</span>; m &lt;= num.length - <span class="integer">1</span>; m++) {
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>                    <span class="keyword">for</span> (<span class="type">int</span> n = m; n &gt; i + <span class="integer">1</span> &amp;&amp; num[n] &lt; num[n - <span class="integer">1</span>]; n--) {
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>                        swap(num, n, n - <span class="integer">1</span>);
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>                    }
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>                }
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>                <span class="keyword">return</span>;
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>            }
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>        }
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    }
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    <span class="predefined-type">Arrays</span>.sort(num);
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>}
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>
<span class="line-numbers"><a href="#n21" name="n21">21</a></span><span class="comment">/* Helper Functions */</span>
<span class="line-numbers"><a href="#n22" name="n22">22</a></span><span class="directive">public</span> <span class="type">void</span> swap(<span class="type">int</span><span class="type">[]</span> num, <span class="type">int</span> i, <span class="type">int</span> j) {
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>    <span class="type">int</span> temp = num[i];
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>    num[i] = num[j];
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    num[j] = temp;
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>}
</pre></div>
</div>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Elements]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/29/remove-elements/"/>
    <updated>2014-06-29T18:28:09-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/29/remove-elements</id>
    <content type="html"><![CDATA[<p><a href="https://oj.leetcode.com/problems/remove-element/">Question</a></p>

<hr />

<p>This question is an easier version of <a href="http://www.codertkk.com/blog/2014/06/25/remove-duplicates-in-array/">Remove duplicates in array</a>. Below follows the code:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>    <span class="directive">public</span> <span class="type">int</span> removeElement(<span class="type">int</span><span class="type">[]</span> A, <span class="type">int</span> elem) {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>        <span class="type">int</span> offset = <span class="integer">0</span>;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; A.length; i++) {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>            <span class="keyword">if</span> (A[i] == elem) {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>                offset++;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>            } <span class="keyword">else</span> {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>                A[i - offset] = A[i];
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>            }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        }
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>        <span class="keyword">return</span> A.length - offset;
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    }
</pre></div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Num Sum]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/28/num-sum/"/>
    <updated>2014-06-28T11:39:45-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/28/num-sum</id>
    <content type="html"><![CDATA[<p>Questions:  </p>

<p><a href="https://oj.leetcode.com/problems/two-sum/"><strong>Two Sum</strong></a> </p>

<p><a href="https://oj.leetcode.com/problems/3sum/"><strong>Three Sum</strong></a> </p>

<p><strong>Two Sum</strong> : <br />
If we use brute force, the time complexity would be O(n^2), we can figure out a better way. Try to think like this, first we get an element(say, at index  <em>i</em>) of the array, next we can determine if <em>target</em>-<em>element</em> is in the array(with the help of other data structures like HashSet). As there would be only one solution, we can safely return if we can find <em>target</em>-<em>element</em>  in the array from index <em>i+1</em> to <em>arr.length-1</em>.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>    <span class="directive">public</span> <span class="type">int</span><span class="type">[]</span> twoSum(<span class="type">int</span><span class="type">[]</span> numbers, <span class="type">int</span> target) {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>        <span class="type">int</span> len = numbers.length;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>        <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Integer</span>&gt; set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; len; i++) {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>            <span class="type">int</span> val = numbers[i];
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>            set.add(val);
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        }
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; len; i++) {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>            <span class="type">int</span> goal = target - numbers[i];
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>            <span class="keyword">if</span> (set.contains(goal)) {
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="integer">1</span>; j &lt; len; j++) {
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>                    <span class="keyword">if</span>(numbers[j] == goal) {
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">int</span><span class="type">[]</span>{i + <span class="integer">1</span>, j + <span class="integer">1</span>};
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>                    }
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>                }
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>            }
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>        }
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>    }
</pre></div>
</div>
</div>

<p><strong>Three Sum</strong>
With the help of three sum’s <a href="http://en.wikipedia.org/wiki/3SUM">wiki page</a>, we can get the following code. Note in order to eliminate duplicate arrays, we need take advantage of HashSet, which can automatically help determine if the elements of two arrayList are the same.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span class="directive">public</span> <span class="type">class</span> <span class="class">Solution</span> {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    <span class="predefined-type">List</span>&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt;&gt; sumList;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="predefined-type">Set</span>&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt;&gt; set;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    <span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt; list;
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">List</span>&lt;<span class="predefined-type">Integer</span>&gt;&gt; threeSum(<span class="type">int</span><span class="type">[]</span> num) {
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        <span class="predefined-type">Arrays</span>.sort(num);
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        sumList = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; num.length - <span class="integer">3</span>; i++) {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>            <span class="type">int</span> first = num[i];
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>            <span class="type">int</span> j = i + <span class="integer">1</span>;
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>            <span class="type">int</span> k = num.length - <span class="integer">1</span>;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>            <span class="keyword">while</span> (j &lt; k) {
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>                <span class="type">int</span> second = num[j];
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>                <span class="type">int</span> third = num[k];
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>                <span class="type">int</span> result = first + second + third;
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>                <span class="keyword">if</span> (result == <span class="integer">0</span>) {
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>                    list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>                    list.add(first);
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>                    list.add(second);
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>                    list.add(third);
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>                    set.add(list);
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>                    j++;
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>                    k--;
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>                } <span class="keyword">else</span> {
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>                    <span class="keyword">if</span> (result &lt; <span class="integer">0</span>) {
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>                        j++;
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>                    } <span class="keyword">else</span> {
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>                        k--;
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>                    }
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>                }
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>            }
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>        }
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>        sumList.addAll(set);
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>        <span class="keyword">return</span> sumList;
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>    }
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>}
</pre></div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Search in Rotated Sorted Array]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/26/search-in-rotated-sorted-array/"/>
    <updated>2014-06-26T17:23:30-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/26/search-in-rotated-sorted-array</id>
    <content type="html"><![CDATA[<p>Q：Suppose a sorted array is rotated at some pivot unknown to you beforehand.You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.</p>

<p>Q2:Follow up for “Search in Rotated Sorted Array”:
What if duplicates are allowed?<br />
Would this affect the run-time complexity? How and why?<br />
Write a function to determine if a given target is in the array.</p>

<hr />

<p>For sorted array <strong>not rotated</strong>, we use binary search, the runtime of which would be O(logn). The basic steps would be : 
&gt;
1. Set <em>left</em> be the left most point of the array, similar to <em>right</em>
2. Set <em>mid</em> to be the mid point of the array : (left + right) / 2
3. If <em>mid</em> element is equal to target, we return the index
4. Otherwise, we compare the <em>mid</em> element with target, and repeat these steps on the subtracted array (either <em>left</em> to <em>mid</em>-1 or <em>mid</em>+1 to right)。
5. If we can’t find one before left &lt;= right, we will return -1.</p>

<p>Now the array is rotated, while when doing binary search, after <em>mid</em> divides the array into two parts, there must be one part that is in sequence. Thus we can adjust the previous solution a little bit, that is, after step 3, we figure out which part is in sequence, then we judge whether the target would reside in the part. If so, actually it becomes same with normal binary search, if not, it must reside in the other part(based on the fact that the target is in the array), then we can repeat the procedure again on the subtracted array. </p>

<p>```java Search in Sorted Array</p>

<pre><code>	while (left &lt;= right) {
		int mid = (left + right) / 2;

		if (A[mid] == target) {
			return mid;
		} else if (A[left] &lt;= A[mid]) {
			if (A[left] &lt;= target &amp;&amp; target &lt; A[mid]) {
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		} else {
			if (A[mid] &lt; target &amp;&amp; target &lt;= A[right]) {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		}
	}
	return -1;
</code></pre>

<p>```</p>

<p>If duplicates are allowed, we have no idea if the part is in sequence by comparing <em>left</em> and <em>mid</em>(or <em>mid</em> and <em>right</em>) as they may be the same.
Thus we need figure if target must reside in one of the two parts(to see if <em>left</em>&lt;target&lt;<em>mid</em> or <em>mid</em> &lt; target &lt; <em>right</em>), if so, we do the same previously. Otherwise, if we could not make sure either of them, we need narrow the range of left to right and repeat the procedure again. By doing so, the runtime would be O(n) in worst. Here is the detail:</p>

<p>```java Search in Sorted Array</p>

<pre><code>	while (left &lt;= right) {
		int mid = (left + right) / 2;
		if (A[mid] == target) {
			return true;
		} else {
			if (A[left] &lt; target &amp;&amp; target &lt; A[mid]) {
				right = mid - 1;
			} else if (A[mid] &lt; target &amp;&amp; target &lt; A[right]) {
				left = mid + 1;
			} else {
				if (A[left] == target) {
					return true;
				} else {
					left++;
				}

				if (A[right] == target) {
					return true;
				} else {
					right--;
				}
			}

		}
	} ```
</code></pre>
]]></content>
  </entry>
  
</feed>
