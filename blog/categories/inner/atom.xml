<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 'Inner | KK's Coding Blog]]></title>
  <link href="http://tangkangkai.github.io/blog/categories/inner/atom.xml" rel="self"/>
  <link href="http://tangkangkai.github.io/"/>
  <updated>2014-07-25T08:32:50-07:00</updated>
  <id>http://tangkangkai.github.io/</id>
  <author>
    <name><![CDATA[Kangkai Tang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Relearn Java Day 6]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/07/24/relearn-java-day-6/"/>
    <updated>2014-07-24T08:14:42-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/07/24/relearn-java-day-6</id>
    <content type="html"><![CDATA[<ul>
  <li>interface
    <ul>
      <li>all methods are abstract : public abstract</li>
      <li>global variable : public static final</li>
      <li>class <em>implements</em> interface : multi implements</li>
      <li>interface <em>extends</em> interface : multi extends</li>
      <li>loose coupling </li>
    </ul>
  </li>
  <li>poymorphism:
    <ul>
      <li>one object, two form</li>
      <li>Father class/interface reference points to child class</li>
      <li>increase the expandability</li>
      <li>premise:
        <ul>
          <li>inheritance</li>
          <li>overide</li>
        </ul>
      </li>
      <li>Casting:
        <ul>
          <li>upcasting Animal a = new Cat();</li>
          <li>downcasting Cat c = (Cat)a;
            <ul>
              <li>use instance of to determine the child class:
  if (a instance of Cat)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>member :
        <ul>
          <li>member variable:
            <ul>
              <li>compile &amp; run : refer to the <strong>reference type</strong> variable</li>
            </ul>
          </li>
          <li>member function:
            <ul>
              <li>compile : refer to the <strong>reference type</strong> function</li>
              <li>run : refer to <strong>actual type</strong> function</li>
            </ul>
          </li>
          <li>static function: no need for binded object
            <ul>
              <li>compile &amp; run : refer to the reference type variable</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>inner class
    <ul>
      <li>inner class can directly access the members in outer class
        <ul>
          <li>it has the reference to the Outer Class : Outer.this</li>
        </ul>
      </li>
      <li>outer class need object of inner class to access the members in it</li>
      <li>other class access inner class:
        <ul>
          <li>Outer.Inner in = new Outer().new Inner();// not static</li>
          <li>Outer.Inner in = new Outer.Inner(); //Outer static</li>
          <li>Outer.Inner.func() // both Outer and Inner are static</li>
          <li>while for most time, inner class is <strong>private</strong></li>
        </ul>
      </li>
      <li>local inner class:
        <ul>
          <li>can only access local members which is final</li>
        </ul>
      </li>
      <li>anonymous inner class:
        <ul>
          <li>premise: inner class extends or implements a outer class or interface</li>
          <li>actually anonymous child class</li>
          <li>new Father Class/Interface() {}.function()</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
]]></content>
  </entry>
  
</feed>
