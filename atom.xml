<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[KK's Coding Blog]]></title>
  <link href="http://tangkangkai.github.io/atom.xml" rel="self"/>
  <link href="http://tangkangkai.github.io/"/>
  <updated>2014-06-26T15:52:56-07:00</updated>
  <id>http://tangkangkai.github.io/</id>
  <author>
    <name><![CDATA[Kangkai Tang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Relearn Java Day 1]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/26/relearn-java-day-1/"/>
    <updated>2014-06-26T07:53:35-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/26/relearn-java-day-1</id>
    <content type="html"><![CDATA[<p>The foundation is so important for a skyscraper, thus I want to rebuild, or, renovate of my java foundation in the next few weeks. I will post valuable points here in this <em>relearn java</em> series. Here is Day 1:</p>

<ol>
<li>Basic Conceptions:

<ul>
<li><strong>Java Virtual Machine(JVM)</strong>:

<ul>
<li>help Java become cross-platform language(note jvm isn&rsquo;t cross-platform)</li>
<li>between language and operating system</li>
</ul>
</li>
<li><strong>Java Runtime Environment(JRE)</strong>

<ul>
<li>JVM + 核心类库</li>
</ul>
</li>
<li><strong>Java Development Kit(JDK)</strong>

<ul>
<li>JRE + javac.exe + jar.exe + &hellip;</li>
</ul>
</li>
</ul>
</li>
<li><p>Comment</p>

<ul>
<li>one line : //</li>
<li>multiple line: /<em>  </em>/</li>
<li>文档注释： /<em>* </em>/</li>
</ul>
</li>
<li><p>Bit computing</p>

<ul>
<li>&amp; and. could used to get several bits of bytes.

<ul>
<li>not the difference between &amp; and &amp;&amp; is &amp;&amp; is more efficient when the left of &amp;&amp; is false(it will stop calculating the right one).</li>
</ul>
</li>
<li>^ xor. note you can get the original number by xor two times

<ul>
<li>change the value of variable a, b in place :<br/>
  a = a ^ b;
  b = a ^ b;
  a = a ^ b;</li>
</ul>
</li>
<li>&lt;&lt; 左移 （该数乘以2的几次方）</li>
<li><blockquote><blockquote><p>右移 （该数除以2的几次方）对于高位出现的空位， 补与原来相同的数</p></blockquote></blockquote></li>
<li><blockquote><blockquote><blockquote><p>无论原来高位是什么 都用0来补</p></blockquote></blockquote></blockquote></li>
</ul>
</li>
<li><p>switch :</p>

<ul>
<li>the types that could be compared ： byte, short, int, char</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates in Array]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/25/remove-duplicates-in-array/"/>
    <updated>2014-06-25T22:37:26-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/25/remove-duplicates-in-array</id>
    <content type="html"><![CDATA[<p>Q1: Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory.</p>

<p>Q2:Follow up for &ldquo;Remove Duplicates&rdquo;: What if duplicates are allowed at most twice?</p>

<hr />

<p>If we adjust the position of every element whenever there happens a duplicate, the running time would be large. In order to be more efficient, we can do in this way: if the element is the same with the previous one, we increase a &ldquo;offset&rdquo;(recording the offset) variable by one. When traversing through every element, say index of i, we adjust the position from i to i &ndash; offset.</p>

<figure class='code'><figcaption><span>Remove duplicate </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates1</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">A</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// we use count to show the offset</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">offset</span><span class="o">++;</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="n">A</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">offset</span><span class="o">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>      
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">offset</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For question 2, the solution is similar except for we need know when to increase the offset. We use a variable &ldquo;count&rdquo; to count, the following code show the details:</p>

<figure class='code'><figcaption><span>Remove duplicate </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">removeDuplicates2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">A</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">count</span><span class="o">++;</span>
</span><span class='line'>              <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                  <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="n">A</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">offset</span><span class="o">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>      <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BFS and DFS]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/25/bfs-and-dfs/"/>
    <updated>2014-06-25T07:33:17-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/25/bfs-and-dfs</id>
    <content type="html"><![CDATA[<p>Recently I&rsquo;ve been doing <a href="https://oj.leetcode.com/problems">LeetCode Problems</a> and found it&rsquo;s tons of fun. Meanwhile I felt my lacking of solid way solving basic questions, e.g. the topic of the post today : BFS and DFS.I searched through the Internet and found <a href="http://www.codeproject.com/Articles/32212/Introduction-to-Graph-with-Breadth-First-Search-BF">this post</a> really helps me a lot.</p>

<p>Basically it&rsquo;s important to know which data structure we use to implement the algorithm, for DFS we use Stack and for BFS we use Queue.</p>

<p><strong>The steps for DFS:</strong></p>

<blockquote><p>Step 1: Push the root node in the Stack.<br/>
Step 2: Loop until stack is empty. <br/>
Step 3: Peek the node of the stack.<br/>
Step 4: If the node has unvisited child nodes, get the unvisited child node, mark it as traversed and push it on stack. <br/>
Step 5: If the node does not have any unvisited child nodes, pop the node from the stack.</p></blockquote>

<p><strong>The steps for DFS:</strong></p>

<blockquote><p>Step 1: Push the root node in the Queue.<br/>
Step 2: Loop until the queue is empty.<br/>
Step 3: Remove the node from the Queue. <br/>
Step 4: If the removed node has unvisited child nodes, mark them as visited and insert the unvisited children in the queue.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Post]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/23/my-first-post/"/>
    <updated>2014-06-23T16:59:37-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/23/my-first-post</id>
    <content type="html"><![CDATA[<p>Hello every one. This will be my new home for my coding journey.<br/>
Here is my code snippet (also used for testing the blog :P)</p>

<div><script src='https://gist.github.com/9968025.js'></script>
<noscript><pre><code>import java.util.Stack;

import org.junit.Test;

public class TreeTraversal {

    Stack&lt;BinaryTreeNode&gt; btStack = new Stack&lt;&gt;();
    BinaryTreeNode current = null;

    // Pre-Order recursion
    public void preOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            System.out.print(bt.data + &quot;  &quot;);
            preOrderRecursion(bt.left);
            preOrderRecursion(bt.right);
        }
    }

    // Pre-Order interation
    public void preOrderIteration(BinaryTreeNode bt) {
        BinaryTreeNode current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                System.out.print(current.data + &quot;  &quot;);// print the data when
                                                        // pushed into the stack
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                current = current.right;
            }
        }
    }

    // In-Order recursion
    public void inOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            inOrderRecursion(bt.left);
            System.out.print(bt.data + &quot;  &quot;);
            inOrderRecursion(bt.right);
        }
    }

    // In-Order Iteration
    public void inOrderIteration(BinaryTreeNode bt) {
        current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                System.out.print(current.data + &quot;  &quot;);// print the data when
                                                        // popped out of stack
                current = current.right;
            }
        }

    }

    // Post-Order Recursion
    public void postOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            postOrderRecursion(bt.left);
            postOrderRecursion(bt.right);
            System.out.print(bt.data + &quot;  &quot;);
        }

    }

    // Post-Order Iteration
    public void postOrderIteration(BinaryTreeNode bt) {
        current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                if (current.isFinished) { // we use isFinished as a flag to see
                                            // if both of the children have been
                                            // visited.
                    System.out.print(current.data + &quot;  &quot;);
                    current = null;
                } else {
                    current.isFinished = true;
                    btStack.push(current);
                    current = current.right;
                }
            }
        }

    }

    @Test
    public void generalTest() {
        BinaryTreeNode root = new BinaryTreeNode(1);
        BinaryTreeNode left = new BinaryTreeNode(2);
        BinaryTreeNode right = new BinaryTreeNode(3);
        root.left = left;
        root.right = right;

        left.left = new BinaryTreeNode(4);
        left.right = new BinaryTreeNode(5);
        right.left = new BinaryTreeNode(6);
        right.right = new BinaryTreeNode(7);
        System.out.println(&quot;========Pre Order Test=========&quot;);
        preOrderRecursion(root);
        System.out.println();
        preOrderIteration(root);
        System.out.println();

        System.out.println(&quot;========In Order Test=========&quot;);
        inOrderRecursion(root);
        System.out.println();
        inOrderIteration(root);
        System.out.println();

        System.out.println(&quot;========Post Order Test=========&quot;);
        postOrderRecursion(root);
        System.out.println();
        postOrderIteration(root);
    }
}

class BinaryTreeNode {
    int data;
    boolean isFinished;
    BinaryTreeNode left = null;
    BinaryTreeNode right = null;

    public BinaryTreeNode(int data) {
        this.data = data;
    }
}
</code></pre></noscript></div>



]]></content>
  </entry>
  
</feed>
