<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[KK's Coding Blog]]></title>
  <link href="http://tangkangkai.github.io/atom.xml" rel="self"/>
  <link href="http://tangkangkai.github.io/"/>
  <updated>2014-06-25T22:38:13-07:00</updated>
  <id>http://tangkangkai.github.io/</id>
  <author>
    <name><![CDATA[Kangkai Tang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates in Array]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/25/remove-duplicates-in-array/"/>
    <updated>2014-06-25T22:37:26-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/25/remove-duplicates-in-array</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BFS and DFS]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/25/bfs-and-dfs/"/>
    <updated>2014-06-25T07:33:17-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/25/bfs-and-dfs</id>
    <content type="html"><![CDATA[<p>Recently I&rsquo;ve been doing <a href="https://oj.leetcode.com/problems">LeetCode Problems</a> and found it&rsquo;s tons of fun. Meanwhile I felt my lacking of solid way solving basic questions, e.g. the topic of the post today : BFS and DFS.I searched through the Internet and found <a href="http://www.codeproject.com/Articles/32212/Introduction-to-Graph-with-Breadth-First-Search-BF">this post</a> really helps me a lot.</p>

<p>Basically it&rsquo;s important to know which data structure we use to implement the algorithm, for DFS we use Stack and for BFS we use Queue.</p>

<p><strong>The steps for DFS:</strong></p>

<blockquote><p>Step 1: Push the root node in the Stack.<br/>
Step 2: Loop until stack is empty. <br/>
Step 3: Peek the node of the stack.<br/>
Step 4: If the node has unvisited child nodes, get the unvisited child node, mark it as traversed and push it on stack. <br/>
Step 5: If the node does not have any unvisited child nodes, pop the node from the stack.</p></blockquote>

<p><strong>The steps for DFS:</strong></p>

<blockquote><p>Step 1: Push the root node in the Queue.<br/>
Step 2: Loop until the queue is empty.<br/>
Step 3: Remove the node from the Queue. <br/>
Step 4: If the removed node has unvisited child nodes, mark them as visited and insert the unvisited children in the queue.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Post]]></title>
    <link href="http://tangkangkai.github.io/blog/2014/06/23/my-first-post/"/>
    <updated>2014-06-23T16:59:37-07:00</updated>
    <id>http://tangkangkai.github.io/blog/2014/06/23/my-first-post</id>
    <content type="html"><![CDATA[<p>Hello every one. This will be my new home for my coding journey.<br/>
Here is my code snippet (also used for testing the blog :P)</p>

<div><script src='https://gist.github.com/9968025.js'></script>
<noscript><pre><code>import java.util.Stack;

import org.junit.Test;

public class TreeTraversal {

    Stack&lt;BinaryTreeNode&gt; btStack = new Stack&lt;&gt;();
    BinaryTreeNode current = null;

    // Pre-Order recursion
    public void preOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            System.out.print(bt.data + &quot;  &quot;);
            preOrderRecursion(bt.left);
            preOrderRecursion(bt.right);
        }
    }

    // Pre-Order interation
    public void preOrderIteration(BinaryTreeNode bt) {
        BinaryTreeNode current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                System.out.print(current.data + &quot;  &quot;);// print the data when
                                                        // pushed into the stack
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                current = current.right;
            }
        }
    }

    // In-Order recursion
    public void inOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            inOrderRecursion(bt.left);
            System.out.print(bt.data + &quot;  &quot;);
            inOrderRecursion(bt.right);
        }
    }

    // In-Order Iteration
    public void inOrderIteration(BinaryTreeNode bt) {
        current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                System.out.print(current.data + &quot;  &quot;);// print the data when
                                                        // popped out of stack
                current = current.right;
            }
        }

    }

    // Post-Order Recursion
    public void postOrderRecursion(BinaryTreeNode bt) {
        if (bt != null) {
            postOrderRecursion(bt.left);
            postOrderRecursion(bt.right);
            System.out.print(bt.data + &quot;  &quot;);
        }

    }

    // Post-Order Iteration
    public void postOrderIteration(BinaryTreeNode bt) {
        current = bt;
        while (current != null || !btStack.isEmpty()) {
            if (current != null) {
                btStack.push(current);
                current = current.left;
            } else {
                current = btStack.pop();
                if (current.isFinished) { // we use isFinished as a flag to see
                                            // if both of the children have been
                                            // visited.
                    System.out.print(current.data + &quot;  &quot;);
                    current = null;
                } else {
                    current.isFinished = true;
                    btStack.push(current);
                    current = current.right;
                }
            }
        }

    }

    @Test
    public void generalTest() {
        BinaryTreeNode root = new BinaryTreeNode(1);
        BinaryTreeNode left = new BinaryTreeNode(2);
        BinaryTreeNode right = new BinaryTreeNode(3);
        root.left = left;
        root.right = right;

        left.left = new BinaryTreeNode(4);
        left.right = new BinaryTreeNode(5);
        right.left = new BinaryTreeNode(6);
        right.right = new BinaryTreeNode(7);
        System.out.println(&quot;========Pre Order Test=========&quot;);
        preOrderRecursion(root);
        System.out.println();
        preOrderIteration(root);
        System.out.println();

        System.out.println(&quot;========In Order Test=========&quot;);
        inOrderRecursion(root);
        System.out.println();
        inOrderIteration(root);
        System.out.println();

        System.out.println(&quot;========Post Order Test=========&quot;);
        postOrderRecursion(root);
        System.out.println();
        postOrderIteration(root);
    }
}

class BinaryTreeNode {
    int data;
    boolean isFinished;
    BinaryTreeNode left = null;
    BinaryTreeNode right = null;

    public BinaryTreeNode(int data) {
        this.data = data;
    }
}
</code></pre></noscript></div>



]]></content>
  </entry>
  
</feed>
